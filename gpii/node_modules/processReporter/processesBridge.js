/*!
GPII Process Reporter processes bridge -- gpii.processes.

Copyright 2014-2016 Inclusive Design Research Centre, OCAD University

Licensed under the New BSD license. You may not use this file except in
compliance with this License.

You may obtain a copy of the License at
https://github.com/gpii/universal/LICENSE.txt
*/

/*global require */

//(function () {
    "use strict";

    var fluid = require("universal");
    var ref = require("ref");

    var gpii = fluid.registerNamespace("gpii");
    var windows = fluid.registerNamespace("gpii.windows");
    var windowsUtils = require("../WindowsUtilities/WindowsUtilities.js");
    var c = windows.API_constants;

    gpii.processes = fluid.registerNamespace("gpii.processes");
    var procList = [];

    fluid.defaults("gpii.processes.native", {
        gradeNames: ["fluid.component"],
        invokers: {
            getProcessList: {
                funcName: "gpii.processes.native.getProcessList",
                args: []
            }
        }
    });

    // Return a list of processes -- a snapshot of the current processes.
    gpii.processes["native"].getProcessList = function () {
        var processes = [];
        var hSnapShot = windows.kernel32.CreateToolhelp32Snapshot(c.TH32CS_SNAPALL, null);
        var pEntry = new windows.PROCESSENTRY32();
        pEntry.dwSize = windows.PROCESSENTRY32.size;
        var hRes = windows.kernel32.Process32First(hSnapShot, pEntry.ref());
        while (hRes) {
            var buf = new Buffer(pEntry.szExeFile);
            var procInfo = {};
            procInfo.command = ref.readCString(buf, 0);
            var hProcess = windows.kernel32.OpenProcess(c.PROCESS_TERMINATE, 0,
                                                        pEntry.th32ProcessID);
            debugger;
            procInfo.pid = pEntry.th32ProcessID;
            procInfo.uid = -1;
            procInfo.gid = -1;
            procInfo.proc = hProcess;
            procInfo.threads = getProcessThreads(procInfo.pid);                                                        
            processes.push(procInfo);
            
            hRes = windows.kernel32.Process32Next(hSnapShot, pEntry.ref());            
        }
        windows.kernel32.CloseHandle(hSnapShot);
        return processes;
    };
    
    // Should this go into WindowsUtilities?
    // https://msdn.microsoft.com/en-us/library/windows/desktop/ms686701(v=vs.85).aspx
    function getProcessThreads (pid) {
        // NOTE:  There is a lot of simlarity to getProcessList() above in
        // terms of accessing information about the threads.
        debugger;
        var threads = [];
        var hThreadSnapShot = windows.kernel32.CreateToolhelp32Snapshot(c.TH32CS_SNAPTHREAD, pid);
        var tEntry = new windows.THREADENTRY32();
        tEntry.dwSize = windows.THREADENTRY32.size;
        var hRes = windows.kernel32.Thread32First(hThreadSnapShot, tEntry.ref());
        while (hRes) {
            var threadInfo = {};
            if (tEntry.th32OwnerProcessID === pid) {
                threadInfo.tid = tEntry.th32ThreadID;
                threadInfo.tpBasePri = tEntry.tpBasePri;
                threadInfo.tpDeltaPri;
                threads.push(threadInfo);
            }
            hRes = windows.kernel32.Thread32Next(hThreadSnapShot, tEntry.ref());
        }
        debugger;
        return threads;
    }

    console.log ("HERE!");
    debugger;
    procList = gpii.processes["native"].getProcessList();
    debugger;
    console.log ("");
    console.log (JSON.stringify(procList));
    
//}());
