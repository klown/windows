/*!
GPII Process Reporter processes bridge -- gpii.processes.

Copyright 2017 Inclusive Design Research Centre, OCAD University

Licensed under the New BSD license. You may not use this file except in
compliance with this License.

You may obtain a copy of the License at
https://github.com/gpii/universal/LICENSE.txt
*/

using System;
using System.Text;
using System.Collections;
using System.Collections.Generic;
using System.Threading;
using System.Threading.Tasks;
using System.Diagnostics;
using System.Dynamic;
using System.Management;

// These for when the tests are in a separate file.
// using gpii.windows.processes;
// using System;
// using System.Threading.Tasks;
// using System.Collections;
// using System.Collections.Generic;

namespace gpii.windows.processes.tests
{
    public class GetProcessesTests
    {
        public async Task<object> Invoke(dynamic input)
        {
            var runAssertion = (Func<object, Task<object>>)input.assert;
            ArrayList testResults = new ArrayList();
            ArrayList asserts = new ArrayList();
            GetProcesses getProcesses = new GetProcesses();
            object[] processes = null;
            int thisPid = -1;
            Exception testError = null;
            

            // Test getProcesses(<command>) using 'node.exe' (expected that this
            // code is called from a node process via edge.js)
            try {
                Task<object> aTask = getProcesses.Invoke("node.exe");
                aTask.Wait();
                processes = (object[]) aTask.Result;
                testError = null;
            }
            catch (Exception e) {
                testError = e;
                processes = null;
            }
            asserts.Add(new {
                message = "Listing node processes",
                expected = 0,
                actual = (processes == null ? 0 : processes.Length),
                assert = "assertNotEquals",
                error = testError
            });
            for (var i = 0; i < processes.Length; i++) {
                thisPid = ((ProcInfo) processes[0]).pid;    // save for later.
                asserts.Add(new {
                    message = "Command Name",
                    expected = "node.exe",
                    actual = ((ProcInfo) processes[i]).command,
                    assert = "assertEquals",
                    error = testError
                });
            }
            testResults.Add(new {
                testName = "GetProcesses(<command>) using the 'process' object itself",
                testAsserts = asserts.ToArray()
            });
            asserts.Clear();

            // Test GetProcesses(<command>) with non-existent command name
            try {
                Task<object> aTask = getProcesses.Invoke("Txe243");
                aTask.Wait();
                processes = (object[]) aTask.Result;
                testError = null;
            }
            catch (Exception e) {
                testError = e;
                processes = null;
            }
            asserts.Add(new {
                message = "Invalid pid",
                expected = 0,
                actual = (processes == null ? 0 : processes.Length),
                assert = "assertEquals",
                error = testError
            });
            testResults.Add(new {
                testName = "GetProcesses(<command>) with non-existent command name",
                testAsserts = asserts.ToArray()
            });
            
            // Test getProcesses(<command>) using node's pid (expected that this
            // is called from a node process)
            try {
                Task<object> aTask = getProcesses.Invoke(thisPid);
                aTask.Wait();
                processes = (object[]) aTask.Result;
                testError = null;
            }
            catch (Exception e) {
                testError = e;
                processes = null;
            }
            asserts.Add(new {
                message = "Listing node processes",
                expected = 0,
                actual = (processes == null ? 0 : processes.Length),
                assert = "assertNotEquals",
                error = testError
            });
            asserts.Add(new {
                message = "Command Name",
                expected = thisPid,
                actual = (processes == null ? -1 : ((ProcInfo) processes[0]).pid),
                assert = "assertEquals",
                error = testError
            });
            testResults.Add(new {
                testName = "GetProcesses(<pid>) using 'node.exe'",
                testAsserts = asserts.ToArray()
            });
            asserts.Clear();

            // Test getProcesses(<pid>) with an invalid pid.
            try {
                Task<object> aTask = getProcesses.Invoke(-1);
                aTask.Wait();
                processes = (object[]) aTask.Result;
                testError = null;
            }
            catch (Exception e) {
                testError = e;
                processes = null;
            }
            asserts.Add(new {
                message = "Invalid pid",
                expected = 0,
                actual = (processes == null ? 0 : processes.Length),
                assert = "assertEquals",
                error = testError
            });
            testResults.Add(new {
                testName = "GetProcesses(<pid>) using invalid pid",
                testAsserts = asserts.ToArray()
            });
            asserts.Clear();

            // Test GetProcesses with no arguments; full list of running processes
            try {
                Task<object> aTask = getProcesses.Invoke(null);
                aTask.Wait();
                processes = (object[]) aTask.Result;
                testError = null;
            }
            catch (Exception e) {
                testError = e;
                processes = null;
            }
            asserts.Add(new {
                message = "Full process list",
                expected = 0,
                actual = (processes == null ? 0 : processes.Length),
                assert = "assertNotEquals",
                error = testError
            });
            ProcInfo systemIdleProcess = null;
            for (int i = 0; i < processes.Length; i++) {
                ProcInfo aProcInfo = (ProcInfo) processes[i];
                if (aProcInfo.pid == 0) {
                    systemIdleProcess = aProcInfo;
                    break;
                }
            }
            asserts.Add(new {
                message = "Process 0 (zero)",
                expected = 0,
                actual = systemIdleProcess,
                assert = "assertNotNull",
                error = testError
            });
            testResults.Add(new {
                testName = "GetProcesses with no arguments; full list of running processes",
                testAsserts = asserts.ToArray()
            });
            asserts.Clear();

            // Call back into node to run jqUnit on all the testResults.
            Console.WriteLine("C# before runAssertion()");
            var result = (int)await runAssertion(testResults.ToArray());
            Console.WriteLine("C# runAssertion() result is " + result);
            return result;
        }
    }
}

public class ProcInfo
{
    public string command = "";
    public int pid = -1;
    public string fullPath = "";
    public string commandLine = "";
    public string state = "";
}

namespace gpii.windows.processes
{
    public class GetProcesses
    {
        public async Task<object> Invoke(dynamic input)
        {
            ManagementObject[] processes = null;
            ArrayList result;

            ManagementObjectCollection moc = new ManagementClass(new ManagementPath("Win32_Process")).GetInstances();
            processes = new ManagementObject[moc.Count];
            moc.CopyTo(processes, 0);
            result = new ArrayList();

            // Check input for specified process id or command name.
            if (input != null) {
                if (input.GetType() == typeof(System.Int32)) {
                    ManagementObject aProcess = Array.Find(
                        processes, p => Convert.ToInt32(p.GetPropertyValue("ProcessId")) == input
                    );
                    if (aProcess != null) {
                        makeAndAppendProcInfo(aProcess, result);
                    }
                } else {
                    ManagementObject[] someProcesses = Array.FindAll(
                        processes, p => p.GetPropertyValue("Name").ToString() == input
                    );
                    foreach (ManagementObject p in someProcesses) {
                        makeAndAppendProcInfo(p, result);
                    }
                }
            }
            // No process specified; get all processes and their info.
            else {
                foreach (ManagementObject p in processes) {
                    makeAndAppendProcInfo(p, result);
                }
            }
            return result.ToArray();
        }

        public static void makeAndAppendProcInfo(ManagementObject processMO, ArrayList procInfos) {
            object propValue;
            Process theProcess;
            int pid = Convert.ToInt32(processMO.GetPropertyValue("ProcessId"));
            // It's possible that the actual process has exited since acquiring its
            // ManagementObject representation (the argument passed to this
            // function).  If so, trying to get its process id (pid) will result in
            // an exception indicating the process is no longer running.  See:
            // https://msdn.microsoft.com/en-us/library/76fkb36k(v=vs.110).aspx#Anchor_1
            try {
                theProcess = Process.GetProcessById(pid);
                ProcInfo procInfo = new ProcInfo();
                procInfo.command = processMO.GetPropertyValue("Name").ToString();
                procInfo.pid = pid;

                propValue = processMO.GetPropertyValue("ExecutablePath");
                if (propValue != null) {
                    procInfo.fullPath = propValue.ToString();
                }
                propValue = processMO.GetPropertyValue("CommandLine");
                if (propValue == null) {
                    propValue = "";
                }
                procInfo.commandLine = propValue.ToString();
                // Should be able to get the state of the process using the
                // "ExecutionState" property, but that is not implemented; see:
                // http://maestriatech.com/wmi.php
                //
                // Use the Process's main thread's state (the first one).
                // Also, map Windows thread states to Linux-y process states.
                switch (theProcess.Threads[0].ThreadState) {
                    case System.Diagnostics.ThreadState.Running:
                    case System.Diagnostics.ThreadState.Wait:
                        procInfo.state = "Running";
                        break;

                    case System.Diagnostics.ThreadState.Initialized:
                    case System.Diagnostics.ThreadState.Ready:
                    case System.Diagnostics.ThreadState.Standby:
                    case System.Diagnostics.ThreadState.Transition:
                        procInfo.state = "Sleeping";
                        break;

                    case System.Diagnostics.ThreadState.Terminated:
                    case System.Diagnostics.ThreadState.Unknown:
                        procInfo.state = "Zombie";
                        break;
                }
                procInfos.Add(procInfo);
            }
            // Process no longer running -- nothing to add.
            catch (ArgumentException e) { }
        }
    }
}


