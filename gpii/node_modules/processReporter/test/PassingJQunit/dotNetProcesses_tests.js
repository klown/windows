/*!
GPII Process Reporter processes bridge -- gpii.processes.

Copyright 2017 Inclusive Design Research Centre, OCAD University

Licensed under the New BSD license. You may not use this file except in
compliance with this License.

You may obtain a copy of the License at
https://github.com/gpii/universal/LICENSE.txt
*/

/*global require */

"use strict";

var path = require("path"),
    // This conditional require is to run the electron version of edge.js
    // when this code runs on electron (gpii-app).
    edge = process.versions.electron ? require("electron-edge") : require("edge"),
    fluid = require("universal"),
    jqUnit = fluid.require("node-jqunit");

var procTests = fluid.registerNamespace("gpii.processes.windows.tests");

// Create JavaScript interfaces to the C# test methods
procTests.testValidCommandName = edge.func({
    source: path.join(__dirname, "dotNetProcessesTests.csx"),
    typeName: "gpii.windows.processes.tests.GetProcessesTests",
    methodName: "TestValidCommandName",
    references: ["System.Management.dll"]
});

procTests.testInvalidCommandName = edge.func({
    source: path.join(__dirname, "dotNetProcessesTests.csx"),
    typeName: "gpii.windows.processes.tests.GetProcessesTests",
    methodName: "TestInvalidCommandName",
    references: ["System.Management.dll"]
});

procTests.testValidPid = edge.func({
    source: path.join(__dirname, "dotNetProcessesTests.csx"),
    typeName: "gpii.windows.processes.tests.GetProcessesTests",
    methodName: "TestValidPid",
    references: ["System.Management.dll"]
});

procTests.testInvalidPid = edge.func({
    source: path.join(__dirname, "dotNetProcessesTests.csx"),
    typeName: "gpii.windows.processes.tests.GetProcessesTests",
    methodName: "TestInvalidPid",
    references: ["System.Management.dll"]
});

procTests.testNoArguments = edge.func({
    source: path.join(__dirname, "dotNetProcessesTests.csx"),
    typeName: "gpii.windows.processes.tests.GetProcessesTests",
    methodName: "TestNoArguments",
    references: ["System.Management.dll"]
});

/**
 * A callback function to pass to C#/.NET for it to call with a set of tests
 * and their results.  The tests are evaluated using jqUnit.
 * @param {Array}      An array of test fixtures each containing an array of
 *                     objects with expected, actual, and/or error results.
 * @param {Function}   A callback to execute when finished, passing control
 *                     back to C#.
 */
procTests.runAssertions = function (testResults, callback) {
    fluid.each(testResults, function (testFixture) {
        jqUnit.test(
            testFixture.testName,
            function () {
                for (var i = 0; i < testFixture.testAsserts.length; i++) {
                    var anAssertion = testFixture.testAsserts[i];
                    if (anAssertion.error !== null) {
                        jqUnit.fail(anAssertion.error);
                    } else {
                        jqUnit[anAssertion.assert](
                            anAssertion.message,
                            anAssertion.expected,
                            anAssertion.actual
                        );
                    }
                }
            });
    });
    callback(null, "success");
};

/**
 * A callback function called from C#/.NET to handle exceptions, and pass back
 * a result.
 * @param {Exception}   If non-null, an exception to throw.
 * @param {Object}      A result if the error parameter is null.
 * @return {Object}     The result if no error; otherwise, throw an exception.
 */
procTests.handleError = function (error, result) {
    if (error) {
        throw error;
    }
    return result;
};

// Execute a set of test scenarios within C#/.NET, collect the test results, and
// evaluate them using the runAssertions() function passed into C# (defined
// above).
procTests.testValidCommandName({assert: procTests.runAssertions}, procTests.handleError);
procTests.testInvalidCommandName({assert: procTests.runAssertions}, procTests.handleError);

// Data structure to pass via testValidPid(), using process's own pid.
procTests.validPidData = {
    assert: procTests.runAssertions,
    pid: process.pid
};
procTests.testValidPid(procTests.validPidData, procTests.handleError);
procTests.testInvalidPid({assert: procTests.runAssertions}, procTests.handleError);
procTests.testNoArguments({assert: procTests.runAssertions}, procTests.handleError);
