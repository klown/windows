# C#/.NET Unit Testing

For the most part, Windows GPII uses `node-ffi` to access Windows OS functionality.  Another route is available via [https://github.com/tjanczuk/edge](`edge.js`).  Using `edge.js` allows one to interface with Windows system level functionality using C#/.NET, by wrapping that implementation inside a JavaScript function running within `node`.  The purpose of edge.js/C#/.NET is to provide a link to Windows native OS specific features that are not directly available from `node`, and to allow calling on them using node/JavaScript.  By way of comparison, Linux GPII uses C++ to build node add-ons to provide the same kind interface between `node` and Linux native OS features.

What is missing currently is any unit testing of the C# code.  As (if) GPII uses C# more and more, unit testing will become necessary.  This branch of the Windows GPII is a exploration on how unit testing might be accomplished.

Two approaches are discussed, one where the C# implementation is treated as an interface accessed by a single JavaScript function where that function alone is tested using the `jqUnit` testing framework.  This approach is similar to how the Linux GPII add-ons are tested.

The second approach uses `edge.js`'s ability to call back into `node` from C#.  Here the C# code runs the test scenario, collects the results, and then passes them back to `node` where the results are evaluated using `jqUnit`.

## Testing a JavaScript C# Proxy from within `node`

Background: `edge.js` supplies a single JavaScript function, `edge.func()` that is used to create an asynchronous JavaScript function proxy for a C# class method.   Here is an example of its use:
```
var dotNetProcesses = edge.func({
    source: path.join(__dirname, "dotNetProcesses.csx"),    // C# source code
    typeName: "gpii.windows.processes.GetProcesses",        // C# class with Invoke() method    
    references: ["System.Management.dll"],                  // Other .NET dependencies       
});
```
`edge.func()` returns a JavaScript function which has the following signature:
```
function dotNetProcesses (dataForCSharp, callback);
```
where `dataForCSharp` can be thought of as a JSON object, and `callback` is a function with two parameters:
```
function callback (error, result);
```
The `dataForCSharp` parameter is flexible, and can be anything, from a simple integer value to a complex object with references to other objects and functions.  When `dotNetProcesses()` is called from JavaScript, `edge` marshalls the `dataForCSharp` and then executes `gpii.windows.processes.GetProcesses.Invoke()` within .NET's CLR, passing `dataForCSharp` as a parameter of `Invoke()`.

If the call to `Invoke()` is successful, the `error` parameter of `callback()` is null, and `result` contains the outcome of executing the C# source code.  The `result` can also be anything; in the case of `dotNetProcesses()`, it is an array of JavaScript objects containing information about running processes.

It's possible to make the JavaScript proxy synchronous by suppling `true` for the `callback` parameter.  In that case, the return value of the JavaScript proxy function (`dotNetProcesses()`) is the same as the `result` parameter of `callback()`.

In the specific case of the Process Reporter module, the `dataForCSharp` is one of the following three options:
- a process name (a string),
- a process ID of a possibly running process (an integer), or
- no argument (undefined).

In all cases, `dotNetProcesses()` returns an array of processes.  If given a process name, the array consists of all running processes with that name, if any.  If given a process ID, the list consists of *the* process with that ID, if there is one.  And, finally, if given no argument, the result is a list of all running processes.

`dotNetProcesses()` is well-defined in terms of its inputs and outputs.  As such, one can write unit tests using `jqUnit` and simply treat `dotNetProcesses()` as any other JavaScript function, running the following test scenarios and their expected outcomes:

- pass the name of process that is known to be running, e.g., "node.exe"
  - expect:  an array of processes each with name "node.exe".  There must be at least one item in the array.
- pass the name of a process that is known to not exist, e.g., "Txe243"
  - expect: an empty array.
- pass the process id of a task that is known to be running.
  - expect: an array with one item whose process id is equal to that passed in.
- pass an invalid process id.
  - expect: an empty array.
- pass no arguments.
  - expect:  an array that is a snapshot of all running processes, i.e., at least one item in the array.

This first approach to unit testing is shown in the file: [`dotNetProcesses_tests.js`](./dotNetProcesses_tests.js)

## Calling `jqUnit/node` from within C#

`edge.js` provides a way to call back into `node` from C# code by passing a function reference as a member of the `dataForCSharp` marshalled and passed to C#.  This feature opens the door to a way of executing tests within C# code, and using `jqUnit` to evaluate the test results.

However, the function passed to C# in this manner must have a prescribed signature.  The function passed is executed asynchronously, and its signature is as follows, using JavaScript syntax:

```
function callNode(dataForNode, function callback);
```
where `dataForNode` is again a JSON object, and `callback()` has the signature:
```
function callback(error, result);
```

Using C# syntax, the function to call `node` from C# has the type:
```
Func<object, Task<object>>
```
or, a function with an `object` as its paramenter that returns a `Task` whose result is an `object`.  Here, the `object` in `Func<object,` is `dataForNode`, and the `object` in `Task<object>` is the `result` parameter from `callback()`.

Given the restriction on the form of the `callNode()`, an implication is that one cannot access `jqUnit` methods directly from C#.  Instead, one must define a wrapper function that internally makes calls to `jqUnit`.

A way to do this is to have the C# code run a number of test scenarios, but delay evaluating them immediately.  Instead the results are collected and then passed as a set of results back to `node` via the `callNode()` wrapper function.  This may or may not be the only way to do things, but it is the technique used in the following.

Here is a working example, where the JavaScript function `runAssertions()` is the `callNode()` wrapper function called from C#, and its `testResults` parameter fulfills the `dataForNode` role.  The `runAssertions()` function is defined in JavaScript in a second version of [`dotNetProcesses_tests.js`](./PassingJQunit/dotNetProcesses_tests.js#L70):
```
var procTests.runAssertions = function (testResults, callback) {
    fluid.each(testResults, function (testFixture) {
        jqUnit.test( ... );
    });
    callback(null, "success");
};
```
`testResults` is an array of `Object`s consisting of:
- a name for the test (string),
- a test failure message (string),
- an expected result (any),
- the actual outcome (any, but the same type as the expected result),
- the name of the `jqUnit.assertX()` method to call (string),
- an error if the C# code threw an exception.

A concrete example is:
```
{
    testName: "GetProcesses(<command>) using 'node.exe'",
    testsAsserts: [
        messaage: "Command Name",
        expected: "node.exe",
        actual: "node.exe",
        assert: "assertEquals",
        error: null
    ]
}
```

The test results are created and their members are filled in by the C# code, and then passed back to `node` via `runAssertions()`.  Then, `fluid.each()` iterates over an array of these "test fixture" `Object`s, calling `jqUnit.test()` for each fixture.  If the `error` is non-null, `jqUnit.fail()` is called.  Otherwise the specified `jqUnit.assertX()` function is run:
```
...
jqUnit.test(
    testFixture.testName,
    function () {
        for (var i = 0; i < testFixture.testAsserts.length; i++) {
            var anAssertion = testFixture.testAsserts[i];
            if (anAssertion.error !== null) {
                jqUnit.fail(anAssertion.error);
            } else {
                jqUnit[anAssertion.assert](
                    anAssertion.message,
                    anAssertion.expected,
                    anAssertion.actual
                );
            }
        }
    });
...
```

As noted, the test scenarios are run in C#/.NET.  The C# code for the tests defines a `GetProcessesTest` class, where the methods of the class execute a single test scenario.  Recall that one of the test cases was getting a list of all processes with a given command name.  That is handled by the following C# method:
```
public async TestValidCommandName (dynamic input) { ... }
```

The JavaScript interface to the C# test methods are created using `edge.func()`; for example:
```
procTests.testValidCommandName = edge.func({
    source: path.join(__dirname, "dotNetProcessesTests.csx"),       // C# source
    typeName: "gpii.windows.processes.tests.GetProcessesTests",     // C# test class
    methodName: "TestValidCommandName",                             // C# test method
    references: ["System.Management.dll"]                           // Other .NET dependencies
});
```

There is a corresponding JavaScript `procTests.testX()` function for each C# `GetProcessesTests.TestX()` method.  The test is initiated in `node` by running each of the `procTests.testX()` generated functions to execute the test scenarios defined by the corresponding C# method.  The `procTests.runAssertions()` function is passed into C# so that it can call back into `node` when the C# code has finished executing the test and collected the results:
```
procTests.testValidCommandName({assert: procTests.runAssertions}, procTests.handleError);
```

The source code for this node-to-C#-then-back-to-node approach is found in the `PassingJQunit` folder:
- JavaScript source: [`dotNetProcesses_tests.js`](./PassingJQunit/dotNetProcesses_tests.js)
- C# source: [`dotNetProcessesTests.csx`](./PassingJQunit/dotNetProcessesTests.csx)

As it happens, the exact same test scenarios are run by this code as in the first case, where the test scenarios are defined solely in `node`.

## Evaluation

Which technique is better -- treating the C#/.NET code as a black box and testing the JavaScript interface function only, as with the first methodology, or running the test code in C# and passing the results back to `node` for evaluation?

The main difference is where the test scenarios are run.  In the first case, while the code tested is implemented in C#, that code is opaque, and only the interface between `node` and C#/.NET is evaluated.  The details of what happens within C# are invisible.

In the second case, the test is run within C#/.NET, and although the same tests are run here as in with the first technique, there is the possibility of a finer degree of control over what is actually tested.  Here, the C# code is not a black box and one can dive deeper into it.

Which is better?  I think it depends on how finely tuned the testing need to be.  If the C# implementation is simple and nearly one-to-one with its JavaScript invocation, then the first method is sufficient.

If, however, the C# code has some tricky logic in it that is only apparent at the level of C#, then that needs testing within C# and the more involved procedure of passing information back and forth between `node` and C#/.NET is required.

Or, use a C# testing framework, such as NUnit, directly :-).



