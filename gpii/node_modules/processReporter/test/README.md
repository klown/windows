C#/.NET Unit Testing
===

GPII has typically used `node-ffi` for accessing Windows OS functionality.  But, another route is available via `edge.js`.  Using `edge.js` allows one to implement some functionality using C#/.NET, while wrapping that implementation inside a `node.js` (JavaScript) function.  The purpose of edge.js/C#/.NET is to get at Windows native OS specific features that are not directly available from `node`, and to allow calling on them from node/JavaScript.  By comparison, in the case of Linux, we use C++ to build node add-ons to provide the same kind
interface between nodejs and Linux native OS features.

What is missing currently is any unit testing of the C# code.  As (if) GPII uses C# more and more, unit testing will become necessary.  This README is a report on how unit testing might be accomplished.

Two approaches are discussed -- one where the C# functionality is treated as an interface accessed by a single JavaScript function, and that funciton alone is tested using the familiar `jqUnit` testing framework.

The second approach uses `edge.js`'s ability to call back into `node` from within C#.  Here the C# code runs the test scenario, and then passes the results back to `node` where the results are input to a standard `jqUnit.test()` function.

Calling `jqUnit/node` from within C#
==
Background: To call into C#/.NET, `edge.js` supplies a single JavaScript function, `edge.func()` that creates a JavaScript function proxy for a C# class method.  Here is an example:
```
var dotNetProcesses = edge.func({
    source: path.join(__dirname, "dotNetProcesses.csx"),    // C# source code
    typeName: "gpii.windows.processes.GetProcesses",        // C# class with Invoke() method    
    references: ["System.Management.dll"],                  // Other .NET dependencies       
});
```
`edge.func()` returns a JavaScript function which has the following signature:
```
function dotNetProcesses (dataForCSharp, callback);
```
where `dataForCSharp` is a JSON object and `callback` is a function with two parameters:
```
function callback (error, result);
```
The `dataForCSharp` parameter is flexible, and can be anything, from a simple integer value to a complex object with references to other objects and functions.

If the call into .NET is successful, the `error` parameter of `callback()` is null, and `result` contains the outcome of executing the C# source code.  `result` can also be anything; in the case of `dotNetProcesses()`, it is an array of running processes.

One can call back into `node` from C# code by setting a function as a member of the `dataForCSharp` parameter passed to C#; however, that function has a (familiar) prescribed signature.  The function passed is asynchronous, and its signature has the same form as the function call into C# (JavaScript):

```
function callNode(dataForNode, function callback);
```
where `dataForNode` is again a JSON object, and `callback()` has the signature:
```
function callback(error, result);
```

The first implication is that one cannot pass `jqUnit` methods directly to nor call them from C#.  Instead, they must wrapped in a function with the proper structure.

A way to do this is to have the C# code run test cases, but not evaluate them immediately.  Instead the results are saved and then passed back via a "`callNode()`" function.  (Note:  I don't know if this is the best way).  Here is an example, where `runAssertions()` is the `callNode()` function called from C#, and its `testResults` parameter fulfills the `dataForNode` role:
```
var runAssertions = function (testResults, callback) {
    fluid.each(testResults, function (testFixture) {
        jqUnit.test( ... );
    });
    ...
};
```
`testResults` is an array of objects with a name for the test, an expected result, the actual outcome, the `jqUnit.assertX()` method to call, a test failure message, and an error if the C# code threw an exception.  For example:
```
{
    testName: "GetProcesses(<command>) using 'node.exe'",
    testsAsserts: [
        messaage: "Command Name",
        expected: "node.exe",
        actual: "node.exe",
        assert: "assertEquals",
        error: null
    ]
}
```

MORE TO COME.


