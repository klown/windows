# C#/.NET Unit Testing

For the most part, Windows GPII has uses `node-ffi` to access Windows OS functionality.  Another route is available via `edge.js`.  Using `edge.js` allows one to interface with Windows system level functionality using C#/.NET, by wrapping that implementation using a JavaScript function run within `node`.  That is the purpose of edge.js/C#/.NET is to provide a link to Windows native OS specific features that are not directly available from `node`, and to allow calling on them using node/JavaScript.  By way of comparison, Linux GPII uses C++ to build node add-ons to provide the same kind interface between `node` and Linux native OS features.

What is missing currently is any unit testing of the C# code.  As (if) GPII uses C# more and more, unit testing will become necessary.  This README is a report on how unit testing might be accomplished.

Two approaches are discussed -- one where the C# implementation is treated as an interface accessed by a single JavaScript function, and that function alone is tested using the `jqUnit` testing framework.  This approach is similar to how the Linux GPII add-ons are tested

The second approach uses `edge.js`'s ability to call back into `node` from within C#.  Here the C# code runs the test scenario, collects the results, and then passes tham back to `node` where the results are evaluated using a `jqUnit.test()` function.

## Testing a JavaScript C# Proxy from within `node`

Background: `edge.js` supplies a single JavaScript function, `edge.func()` that is used to create an asynchronous JavaScript function proxy for a C# class method.   Here is an example of its use:
```
var dotNetProcesses = edge.func({
    source: path.join(__dirname, "dotNetProcesses.csx"),    // C# source code
    typeName: "gpii.windows.processes.GetProcesses",        // C# class with Invoke() method    
    references: ["System.Management.dll"],                  // Other .NET dependencies       
});
```
`edge.func()` returns a JavaScript function which has the following signature:
```
function dotNetProcesses (dataForCSharp, callback);
```
where `dataForCSharp` can be thought of as a JSON object, and `callback` is a function with two parameters:
```
function callback (error, result);
```
The `dataForCSharp` parameter is flexible, and can be anything, from a simple integer value to a complex object with references to other objects and functions.  When `dotNetProcesses()` is called from JavaScript, `edge` marshalls the `dataForCSharp` and then executes `gpii.windows.processes.GetProcesses.Invoke()` within .NET's CLR (Common Language Runtime), passing `dataForCSharp` as a parameter of `Invoke()`.

If the call to `Invoke()` is successful, the `error` parameter of `callback()` is null, and `result` contains the outcome of executing the C# source code.  The `result` can also be anything; in the case of `dotNetProcesses()`, it is an array of JavaScript objects containing information about running processes.

It's possible to make the JavaScript proxy synchronous by suppling `true` for the `callback` parameter.  In that case, the return value of the JavaScript proxy function (`dotNetProcesses()`) is the same as the `result` parameter of `callback()`.

In the specific case of the Process Reporter, the `dataForCSharp` is one of the following three options:
- a process name (a string),
- a process ID of a possibly running process (an integer), or
- no argument (undefined).

In all cases, `dotNetProcesses()` returns an array of processes.  If given a process name, the array consists of all running processes with that name, if any.  It given a process ID, the list consists of *the* process with that ID, if there is one.  And, finally, if given no argument, the result is a list of all running processes.

`dotNetProcesses()` is well-defined in terms of its inputs and outputs.  As such, one could write unit tests using `jqUnit` and simply treat `dotNetProcesses()` as any other JavaScript function, runhing the following test scenarios and their expected outcomes:

- pass the name of process that is known to be running, e.g., "node.exe"
  - expect:  an array of processes each with name "node.exe".  There must be at least one item in the array.
- pass the name of a process that is known to not exist, e.g., "Txe243"
  - expect: an empty array.
- pass the process id of a task that is known to be running.
  - expect: an array with one item whose process id is equal to that passed in.
- pass an invalid process id.
  - expect: an empty array.
- pass no arguments.
  - expect:  an array that is a snapshot of all running processes.

This first approach to unit testing is shown in the file: [`dotNetProcesses_tests.js`](./dotNetProcesses_tests.js)

## Calling `jqUnit/node` from within C#

`edge.js` provides a way to call back into `node` from C# code by passsing a function reference as a member of the `dataForCSharp` marshalled and passed to C#.  This ability opens the door to a way executing tests within the C# code itself, but use `jqUnit` to evaluate the test results.

However, the function passed to C# in this manner must have a prescribed signature.  The function passed is executed asynchronously, and its signature is as follows, using JavaScript syntax:

```
function callNode(dataForNode, function callback);
```
where `dataForNode` is again a JSON object, and `callback()` has the signature:
```
function callback(error, result);
```

Using C# syntax, the function to call `node` from C# has the type:
```
Func<object, Task<object>>
```
or, a function with an `object` as its paramenter that returns a `Task` whose result is an `object`.  Here, the `object` in `Func<object,` is `dataForNode`, and the `object` in `Task<object>` is the `result` parameter from `callback()`.

Given the restriction on the form of the `callNode()`, an implication is that one cannot pass `jqUnit` methods directly to (nor call them from) C#.  Instead, one must define a wrapper function that internally makes use of `jqUnit`.

Niggling implementation detail specific to the Process Reporter:  One way to do this is to have the C# code run a number of test scernarios, but delay evaluating them immediately.  Instead the results are collected and then passed as a set of results back to `node` via the "`callNode()`" wrapper function.  This may or may not be the only way to do things, but it is the technique used in the following.

Here is a working example, where the JavaScript function `runAssertions()` is the `callNode()` wrapper function called from C#, and its `testResults` parameter fulfills the `dataForNode` role.  The `runAssertions()` function is defined on the JavaScript in a second version of [`dotNetProcesses_tests.js`](./PassingJQunit/dotNetProcesses_tests.js#L38):
```
var runAssertions = function (testResults, callback) {
    fluid.each(testResults, function (testFixture) {
        jqUnit.test( ... );
    });
    callback(null, "success");
};
```
`testResults` is an array of `Object`s consisting of a name for the test, an expected result, the actual outcome, the `jqUnit.assertX()` method to call, a test failure message, and an error if the C# code threw an exception.  For example:
```
{
    testName: "GetProcesses(<command>) using 'node.exe'",
    testsAsserts: [
        messaage: "Command Name",
        expected: "node.exe",
        actual: "node.exe",
        assert: "assertEquals",
        error: null
    ]
}
```
`fluid.each()` iterates over an array of such "test fixture" objects.

As noted, the test scenarios are run in C#/.NET.  That is initiated by using `edge.func()` to create a JavaScript function named `dotNetProcessesTests()` that simply calls into C# to execute the test scenarios defined by the C# code.  The `runAssertions()` function is passed into C# so that it can call back into `node` when it has finished executing the test scenarios and collected the 
results:

```dotNetProcessesTests({assert: runAssertions}, function (error, result) { ... });
```

The source code for this node-to-C#-then-back-to-node approach is found in the `PassingJQunit` folder:
- JavaScript source: [`dotNetProcesses_tests.js`](./PassingJQunit/dotNetProcesses_tests.js)
- C# source: [`dotNetProcessesTests.csx`](./PassingJQunit/dotNetProcessesTests.csx)

As it happens, the exact same test scenarios are run by this code as in the first case, where the test scenarios are defined in `node`.

## Evaluation

Which technique is better -- treating the C#/.NET code as a black box and testing the JavaScript interface function only -- as with the first mathodology -- or passing a function to C# to call back into `node`?

The main difference is where the test scenarios are run.  In the first case, while the code tested is implemented in C#, that is a black box where only the interface bewteen `node` and C#/.NET is evaluated.  All of the specifics of what happens in C# is opaque.  In the second case, since the tests are set up within C#/.NET, a finer degree of testing is possible since the test is executed in C# itself.

Thus, which technique is better depends on the task at hand.  If the C# code is relatively simple then it can be adequately tested by the first method.  If the C# code is more complex, and had some tricky logic within it, then it should be tested using the latter technique.



