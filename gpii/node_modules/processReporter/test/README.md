# C#/.NET Unit Testing

Windows GPII has typically used `node-ffi` for accessing Windows OS functionality.  Another route is available via `edge.js`.  Using `edge.js` allows one to interface with some Windows system level functionality using C#/.NET, and wrapping that implementation within a JavaScript/node.  That is the purpose of edge.js/C#/.NET is to get at Windows native OS specific features that are not directly available from `node`, and to allow calling on them using node/JavaScript.  By way of comparison, in the case of Linux GPII, we use C++ to build node add-ons to provide the same kind interface between `node` and Linux native OS features.

What is missing currently is any unit testing of the C# code.  As (if) GPII uses C# more and more, unit testing will become necessary.  This README is a report on how unit testing might be accomplished.

Two approaches are discussed -- one where the C# implementation is treated as an interface accessed by a single JavaScript function, and that funciton alone is tested using the `jqUnit` testing framework.

The second approach uses `edge.js`'s ability to call back into `node` from within C#.  Here the C# code runs the test scenario, and then passes the results back to `node` where the results are input to a standard `jqUnit.test()` function.

## Testing a JavaScript C# Proxy from within `node`

Background: `edge.js` supplies a single JavaScript function, `edge.func()` that is used to create an asynchronous JavaScript function proxy for a C# class method.   Here is an example:
```
var dotNetProcesses = edge.func({
    source: path.join(__dirname, "dotNetProcesses.csx"),    // C# source code
    typeName: "gpii.windows.processes.GetProcesses",        // C# class with Invoke() method    
    references: ["System.Management.dll"],                  // Other .NET dependencies       
});
```
`edge.func()` returns a JavaScript function which has the following signature:
```
function dotNetProcesses (dataForCSharp, callback);
```
where `dataForCSharp` can be thought of as a JSON object, and `callback` is a function with two parameters:
```
function callback (error, result);
```
The `dataForCSharp` parameter is flexible, and can be anything, from a simple integer value to a complex object with references to other objects and functions.  When `dotNetProcesses()` is called from JavaScript, `edge` marshalls the `dataForCSharp` and executes the `gpii.windows.processes.GetProcesses.Invoke()` within .NET's CLR (Common Language Runtime), passing it the `dataForCSharp`.

If the call to `Invoke()` is successful, the `error` parameter of `callback()` is null, and `result` contains the outcome of executing the C# source code.  `result` can also be anything; in the case of `dotNetProcesses()`, it is an array of running processes.

It's possible to make the JavaScript proxy synchronous by suppling `true` for the `callback` parameter.  In that case, the return value of the JavaScript proxy function (`dotNetProcesses()`) is the result.

In the specific case of the Process Reporter, the `dataForCSharp` is one of the following three options:
- a process name (a string),
- a process ID of a possibly running process (an integer), or
- no argument (undefined).

In all cases, `dotNetProcesses()` returns an array of processes.  If given a process name, the array consists of all running processes with that name, if any.  It given a process ID, the list consists of 'the' process with that ID, if there is one.  And, finally, if given no argument, the result is s list of all running processes.

`dotNetProcesses()` is well-defined in terms of its inputs and outputs.  As such, one could write unit tests using `jqUnit` and simply treat `dotNetProcesses()` as any other JavaScript function, runhing the following test scenarios and their expected outcomes:

- pass the name of process that is known to be running, e.g., "node.exe"
  - expect:  an array of processes each with name "node.exe", and there mus be at least one item in the array.
- pass the name of a process that is known to not exist, e.g., "Txe243"
  - expect: an empty array.
- pass the process id of a task that is known to be running.
  - expect: an array with one item whose process id is equal to that passed in.
- pass an invalid process id.
  - expect: an empty array.
- pass no arguments.
  - expect:  an arary that is a snapshot of all running processes.

This first approach to unit testing is shown in the file: [`dotNetProcesses_tests.js`](./dotNetProcesses_tests.js)

The downside is that the minutiae of the C# code is not tested.

## Calling `jqUnit/node` from within C#

One can call back into `node` from C# code by setting a function as a member of the `dataForCSharp` marshalled and passed to C#.  This opens the door to allowing a way of testing the C# code specifcally.

However, the function passed to C# in this manner must have a prescribed signature.  The function passed is asynchronous, and its signature is as follows, using JavaScript syntax:

```
function callNode(dataForNode, function callback);
```
where `dataForNode` is again a JSON object, and `callback()` has the signature:
```
function callback(error, result);
```

Using C# syntax, the function to call `node` from C# has the signature:
```
Func<object, Task<object>>
```
or, a function with an `object` as its paramenter that returns a `Task` whose result is an `object`.  Here, the `object` in `Func<object,` is `dataForNode`, and the `object` in `Task<object>` is the `result`.

Given the restriction on the form of the `callNode()`, an implication is that one cannot pass `jqUnit` methods directly to nor call them from C#.  Instead, they must wrapped in a function with the proper structure.

One way to do this is to have the C# code run a number of test scernarios, but delay evaluating them immediately.  Instead the results are collected and then passed back via the "`callNode()`" wrapper function as a set of results.  (Note:  I don't know if this is the best way).

Here is an example, where `runAssertions()` is the `callNode()` wrapper function called from C#, and its `testResults` parameter fulfills the `dataForNode` role.  The `runAssertions()` function is defined on the JavaScript size of things:
```
var runAssertions = function (testResults, callback) {
    fluid.each(testResults, function (testFixture) {
        jqUnit.test( ... );
    });
    ...
};
```
`testResults` is an array of `Object`s with a name for the test, an expected result, the actual outcome, the `jqUnit.assertX()` method to call, a test failure message, and an error if the C# code threw an exception.  For example:
```
{
    testName: "GetProcesses(<command>) using 'node.exe'",
    testsAsserts: [
        messaage: "Command Name",
        expected: "node.exe",
        actual: "node.exe",
        assert: "assertEquals",
        error: null
    ]
}
```

MORE TO COME.


